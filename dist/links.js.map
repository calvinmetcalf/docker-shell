{"version":3,"sources":["../lib/links.js"],"names":["async","require","debug","linkLabels","parseLink","link","parts","split","length","name","replace","trim","alias","filterContainers","docker","label","value","done","opts","filters","JSON","stringify","listContainers","findLabeledContainers","labels","reduce","undefined","found","err","containers","findLabeledContainer","resolveLinks","links","map","parsed","Error","resolve","resolved","join","getContainer","inspect","container","Id","module","exports"],"mappings":"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","file":"links.js","sourcesContent":["'use strict';\n\nconst async = require('async');\nconst debug = require('debug')('docker-shell:links');\nconst linkLabels = ['com.docker-shell.link', 'com.docker.compose.service'];\n\n// Parse docker link syntax into sanitized name, alias pair\n// e.g. redis:db  -> [redis, db]\n//      mongo     -> [mongo, mongo]\n//      /db_1     -> [db_1, db_1]\n// Returns undefined on parse failure\nfunction parseLink(link) {\n  if (typeof link !== 'string') return;\n\n  const parts = link.split(':');\n  if (parts.length > 2 || !parts[0].length) return;\n\n  const name = parts[0].replace(/^\\//, '').trim();\n  if (!name.length) return;\n\n  const alias = parts.length === 1 ? name : parts[1].trim();\n  if (!alias.length) return;\n\n  return [name, alias];\n}\n\n// List all containers matching a label = value filter\nfunction filterContainers(docker, label, value, done) {\n  const opts = {\n    filters: JSON.stringify({\n      label: [`${label}=${value}`]\n    })\n  };\n  docker.listContainers(opts, done);\n}\n\n// Find the first label with containers matching value and return the containers\n// Errors are considered a non-match and are never returned.\n// Callback is called with undefined if no labels matched any containers.\nfunction findLabeledContainers(docker, labels, value, done) {\n  // Hack reduce error to work like find\n  async.reduce(labels, undefined, (found, label, done) => {\n    filterContainers(docker, label, value, (err, containers) => {\n      if (found) return done(found);\n      if (containers && containers.length > 0) {\n        debug('[runner:docker] found containers with label', label);\n        return done(containers);\n      }\n      debug('[runner:docker] no containers with label', label);\n      done();\n    });\n  }, containers => {\n    done(undefined, containers);\n  });\n}\n\n// Find the first label with a container matching value and return the container\n// Errors are considered a non-match and are never returned.\n// Callback is called with undefined if no labels matched any container.\nfunction findLabeledContainer(docker, labels, value, done) {\n  findLabeledContainers(docker, labels, value, (err, containers) => {\n    if (containers && containers.length > 0) {\n      return done(undefined, containers[0]);\n    }\n    done();\n  });\n}\n\n// Resolves strider docker runner links into docker links using names and labels\n// First checks for a container with the given name, then searches for\n// the first container matching a set of predefined labels.\n// Callback called with an error if the link cannot be parsed or no matching\n// container is found.\nfunction resolveLinks(docker, links, done) {\n  async.map(links, function (link, done) {\n\n    let parsed = parseLink(link);\n    if (!parsed) return done(new Error(`Invalid link: ${link}`));\n\n    function resolve(name) {\n      const resolved = [name, parsed[1]].join(':');\n      debug('[runner:docker] resolved link', link, resolved);\n      return done(undefined, resolved);\n    }\n\n    // Try to find a container by name (or id)\n    const name = parsed[0];\n    docker.getContainer(name).inspect((err, container) => {\n      if (!err && container) return resolve(name);\n      debug('[runner:docker] no container with name', name);\n      // Try to find a container by label\n      findLabeledContainer(docker, linkLabels, name, (err, container) => {\n        if (!err && container) return resolve(container.Id);\n        debug('[runner:docker] no container with label', name);\n        done(new Error(`No container found for link: ${link}`));\n      });\n    });\n  }, done);\n}\n\nmodule.exports = {\n  parseLink: parseLink,\n  filterContainers: filterContainers,\n  findLabeledContainers: findLabeledContainers,\n  findLabeledContainer: findLabeledContainer,\n  resolveLinks: resolveLinks\n};\n"]}