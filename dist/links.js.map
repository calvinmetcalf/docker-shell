{"version":3,"sources":["../lib/links.js"],"names":["parseLink","filterContainers","findLabeledContainers","findLabeledContainer","resolveLinks","debug","linkLabels","link","parts","split","length","name","replace","trim","alias","docker","label","value","opts","filters","JSON","stringify","listContainers","labels","race","map","then","containers","links","parsed","reject","Error","getContainer","inspect","container","resolved","join","catch","err"],"mappings":"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","file":"links.js","sourcesContent":["import Bluebird from 'bluebird';\nimport setupDebug from 'debug';\n\nconst debug = setupDebug('docker-shell:links');\nconst linkLabels = ['com.docker-shell.link', 'com.docker.compose.service'];\n\n/**\n * Parse docker link syntax into sanitized name, alias pair\n * e.g. redis:db  -> [redis, db]\n *     mongo     -> [mongo, mongo]\n *     /db_1     -> [db_1, db_1]\n * Returns undefined on parse failure\n */\nexport function parseLink(link) {\n  if (typeof link !== 'string') return;\n\n  const parts = link.split(':');\n  if (parts.length > 2 || !parts[0].length) return;\n\n  const name = parts[0].replace(/^\\//, '').trim();\n  if (!name.length) return;\n\n  const alias = parts.length === 1 ? name : parts[1].trim();\n  if (!alias.length) return;\n\n  return [name, alias];\n}\n\n/**\n * List all containers matching a label = value filter\n *\n * @returns {Promise}\n */\nexport function filterContainers(docker, label, value) {\n  const opts = {\n    filters: JSON.stringify({\n      label: [`${label}=${value}`]\n    })\n  };\n\n  return docker.listContainers(opts);\n}\n\n/**\n * Find the first label with containers matching value and return the containers\n * Errors are considered a non-match and are never returned.\n * Callback is called with undefined if no labels matched any containers.\n */\nexport function findLabeledContainers(docker, labels, value) {\n  // Hack reduce error to work like find\n  debugger;\n  return Bluebird.race(labels.map((label) => {\n    return filterContainers(docker, label, value).then((containers) => {\n      if (containers && containers.length > 0) {\n        debug('[runner:docker] found containers with label', label);\n        return containers;\n      }\n      debug('[runner:docker] no containers with label', label);\n    });\n  }));\n}\n\n/**\n * Find the first label with a container matching value and return the container\n * Errors are considered a non-match and are never returned.\n * Callback is called with undefined if no labels matched any container.\n */\nexport function findLabeledContainer(docker, labels, value) {\n  return findLabeledContainers(docker, labels, value).then((containers) => {\n    if (containers && containers.length > 0) {\n      return containers[0];\n    }\n  });\n}\n\n/**\n * Resolves strider docker runner links into docker links using names and labels\n * First checks for a container with the given name, then searches for\n * the first container matching a set of predefined labels.\n * Callback called with an error if the link cannot be parsed or no matching\n * container is found.\n */\nexport function resolveLinks(docker, links) {\n  return Bluebird.map(links, (link) => {\n    let parsed = parseLink(link);\n\n    if (!parsed) {\n      return Bluebird.reject(new Error(`Invalid link: ${link}`));\n    }\n\n    const name = parsed[0];\n\n    // Try to find a container by name (or id)\n    return docker.getContainer(name).inspect().then((container) => {\n      if (container) {\n        const resolved = [name, parsed[1]].join(':');\n        debug('[runner:docker] resolved link', link, resolved);\n        return resolved;\n      }\n\n      debug('[runner:docker] no container with name', name);\n      // Try to find a container by label\n      return findLabeledContainer(docker, linkLabels, name)\n        .then((container) => {\n          if (container) {\n            let resolved = [name, parsed[1]].join(':');\n            debug('[runner:docker] resolved link', link, resolved);\n            return resolved;\n          }\n\n          debug('[runner:docker] no container with label', name);\n        })\n        .catch((err) => {\n          debug('[runner:docker] errored finding labeled container');\n          return Bluebird.reject(new Error(`No container found for link: ${link}`));\n        });\n    });\n  });\n}\n"]}